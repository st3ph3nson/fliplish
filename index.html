<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fliplish Translator</title>

  <style>
    :root {
      --bg: #d8cbb8;
      --panel: rgba(255,255,255,0.78);
      --border: rgba(17, 24, 39, 0.18);
      --text: #111827;
    }

    * { box-sizing: border-box; }
    html, body { overflow-x: hidden; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
      margin: 24px;
      line-height: 1.35;
      background: var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      outline: none;
    }

    .row {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
      align-items: center;
    }

    button, select {
      padding: 10px 12px;
      font-size: 15px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.65);
      cursor: pointer;
    }

    .hint { opacity: 0.75; font-size: 13px; margin-top: 8px; }
  </style>
</head>

<body>
<div class="container">
  <h1>Fliplish Translator</h1>

  <textarea id="input" placeholder="Type English (or coded text) here..."></textarea>

  <div class="row">
    <button id="encode">Encode ‚Üí</button>
    <button id="decode">‚Üê Decode</button>
    <button id="clear">Clear</button>

    <label>
      Suffix mode:
      <select id="suffixMode">
        <option value="single" selected>Single</option>
        <option value="aeo">AEO Rotate</option>
        <option value="random">Random</option>
      </select>
    </label>

    <label>
      Suffix:
      <select id="suffix"></select>
    </label>

    <label>
      Move letters:
      <select id="moveN">
        <option value="1" selected>1</option>
        <option value="2">2</option>
      </select>
    </label>

    <label>
      Preserve capitalization:
      <select id="caps">
        <option value="yes">Yes</option>
        <option value="no" selected>No</option>
      </select>
    </label>
  </div>

  <textarea id="output" readonly></textarea>

  <div class="hint">
    How Fliplish works:
Each word is encoded by moving the first one or two letters to the end of the word and then adding a suffix.
To decode, the suffix is removed and those letters are moved back to the front, restoring the original word.
Punctuation, spacing, and contractions (like I‚Äôm or don‚Äôt) are preserved so the text stays readable.
  </div>
</div>

<script>
const LETTERS = "abcdefghijklmnopqrstuvwxyz";

const inputEl = document.getElementById("input");
const outputEl = document.getElementById("output");
const suffixEl = document.getElementById("suffix");
const suffixModeEl = document.getElementById("suffixMode");
const moveNEl = document.getElementById("moveN");
const capsEl = document.getElementById("caps");

/* ‚úÖ Suffix dropdown: SH/CH/TH first, then a‚Äìz */
(function initSuffix() {
  const special = ["sh", "ch", "th"];
  const all = [...special, ...LETTERS.split("")];

  suffixEl.innerHTML = "";
  for (const s of all) {
    const o = document.createElement("option");
    o.value = s;
    o.textContent = s.toUpperCase(); // looks nicer in the UI
    if (s === "a") o.selected = true; // default stays "a"
    suffixEl.appendChild(o);
  }
})();

function tokenize(text) {
  return text.match(/[A-Za-z]+(?:['‚Äô][A-Za-z]+)*|[^A-Za-z]+/g) || [];
}

function detectCapsStyle(word) {
  if (word === word.toUpperCase()) return "upper";
  if (word[0] === word[0].toUpperCase()) return "title";
  return "lower";
}

/* üîí Apostrophe-safe helpers */
function splitApostrophes(word) {
  const letters = [];
  const apos = [];
  [...word].forEach((c, i) => {
    if (c === "'" || c === "‚Äô") apos.push({ i, c });
    else letters.push(c);
  });
  return { letters: letters.join(""), apos };
}

function restoreApostrophes(word, apos) {
  const arr = [...word];
  apos.forEach(({ i, c }) => arr.splice(i, 0, c));
  return arr.join("");
}

function encodeWord(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();
  const { letters, apos } = splitApostrophes(lower);

  if (!letters) return word;

  const n = Math.min(moveN, letters.length);
  let coded = letters.slice(n) + letters.slice(0, n) + suffix;
  coded = restoreApostrophes(coded, apos);

  if (!preserveCaps) return coded;
  if (style === "upper") return coded.toUpperCase();
  if (style === "title") return coded[0].toUpperCase() + coded.slice(1);
  return coded;
}

function decodeWord(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();

  /* ‚úÖ handles 1-char or 2-char suffix */
  if (!lower.endsWith(suffix)) return word;

  const core = lower.slice(0, -suffix.length);
  const { letters, apos } = splitApostrophes(core);

  const n = Math.min(moveN, letters.length);
  let plain = letters.slice(-n) + letters.slice(0, -n);
  plain = restoreApostrophes(plain, apos);

  if (!preserveCaps) return plain;
  if (style === "upper") return plain.toUpperCase();
  if (style === "title") return plain[0].toUpperCase() + plain.slice(1);
  return plain;
}

function randomSuffix() {
  return LETTERS[Math.floor(Math.random() * LETTERS.length)];
}

function getSuffixForWord(i) {
  if (suffixModeEl.value === "aeo") return ["a","e","o"][i % 3];
  if (suffixModeEl.value === "random") return randomSuffix();
  return suffixEl.value; // single (can be sh/ch/th or a‚Äìz)
}

/* ‚úÖ for Random decode only (still 1-letter random) */
function lastCharSuffix(w) {
  const c = w[w.length - 1];
  return /[a-z]/i.test(c) ? c.toLowerCase() : null;
}

function transform(text, mode) {
  const preserveCaps = capsEl.value === "yes";
  const moveN = +moveNEl.value;
  let wordIndex = 0;

  return tokenize(text).map(tok => {
    if (/^[A-Za-z]/.test(tok)) {
      let suffix;

      if (mode === "decode") {
        if (suffixModeEl.value === "random") {
          // random decode: suffix is whatever last letter is
          suffix = lastCharSuffix(tok) || "a";
        } else if (suffixModeEl.value === "aeo") {
          // aeo decode: suffix is based on word index
          suffix = ["a","e","o"][wordIndex % 3];
        } else {
          // single decode: use selected suffix (supports SH/CH/TH)
          suffix = suffixEl.value;
        }
      } else {
        suffix = getSuffixForWord(wordIndex);
      }

      wordIndex++;
      return mode === "encode"
        ? encodeWord(tok, suffix, preserveCaps, moveN)
        : decodeWord(tok, suffix, preserveCaps, moveN);
    }
    return tok;
  }).join("");
}

document.getElementById("encode").onclick = () =>
  outputEl.value = transform(inputEl.value, "encode");

document.getElementById("decode").onclick = () =>
  outputEl.value = transform(inputEl.value, "decode");

document.getElementById("clear").onclick = () => {
  inputEl.value = "";
  outputEl.value = "";
};
</script>
</body>
</html>
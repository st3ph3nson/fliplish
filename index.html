<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>English → Conlang Dictionary</title>
  <style>
    /* Clean + basic */
    :root { color-scheme: dark; }
    body{
      margin:0; padding:20px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#0b0f17; color:#e8eefc;
    }
    h1{ margin:0 0 6px; font-size:20px; }
    .sub{ margin:0 0 14px; opacity:.75; font-size:13px; }

    .bar{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 0 0 14px; }
    input, select, button{
      background:#0f1626; color:#e8eefc;
      border:1px solid #22314f; border-radius:10px;
      padding:10px 12px; font-size:14px;
    }
    input{ flex:1 1 280px; }
    button{ cursor:pointer; }
    button:hover{ border-color:#3a5488; }

    .meta{ font-size:12px; opacity:.75; margin-bottom:10px; }

    /* Table */
    .wrap{
      border:1px solid #22314f; border-radius:12px;
      overflow:hidden; background:#0f1626;
    }
    table{ width:100%; border-collapse:collapse; }
    thead th{
      text-align:left; font-size:12px; letter-spacing:.08em; text-transform:uppercase;
      padding:12px 12px; background:#0d1423; border-bottom:1px solid #22314f;
      opacity:.85;
    }
    tbody td{
      padding:12px 12px; border-bottom:1px solid #1b2944; vertical-align:top;
      font-size:14px;
    }
    tbody tr:last-child td{ border-bottom:none; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted{ opacity:.75; }
    .right{ text-align:right; }

    /* Small screens: keep it readable */
    @media (max-width: 560px){
      thead{ display:none; }
      table, tbody, tr, td{ display:block; width:100%; }
      tbody tr{ border-bottom:1px solid #22314f; }
      tbody tr:last-child{ border-bottom:none; }
      tbody td{ border-bottom:none; padding:10px 12px; }
      tbody td[data-label]::before{
        content: attr(data-label);
        display:block; font-size:11px; letter-spacing:.08em; text-transform:uppercase;
        opacity:.65; margin-bottom:4px;
      }
    }
  </style>
</head>
<body>
  <h1>Dictionary (English → Conlang)</h1>
  <p class="sub">Simple list. Searchable. Keeps notes. Sorted A→Z by English.</p>

  <div class="bar">
    <input id="q" type="search" placeholder="Search (English or conlang)…" autocomplete="off" />
    <select id="mode" aria-label="Search mode">
      <option value="both" selected>English + Conlang</option>
      <option value="en">English only</option>
      <option value="cl">Conlang only</option>
      <option value="notes">Notes only</option>
    </select>
    <button id="clear" type="button">Clear</button>
  </div>

  <div class="meta">
    Entries: <span id="count" class="mono">0</span> • Showing: <span id="showing" class="mono">0</span>
  </div>

  <div class="wrap">
    <table>
      <thead>
        <tr>
          <th style="width:36%;">English</th>
          <th style="width:18%;">Conlang</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </div>

<script>
  // Edit this list. Keep English in any order—code sorts it A→Z automatically.
  const LEXICON = [
    { en: "after",  cl: "nra", notes: "" },
    { en: "and",    cl: "sap", notes: "Connector / conjunction." },
    { en: "bed",    cl: "ga",  notes: "" },
    { en: "before", cl: "poi", notes: "" },
    { en: "become / get", cl: "pwe", notes: "State-change verb." },
    { en: "dream",  cl: "nme", notes: "Can be used as verb or concept." },
    { en: "good",   cl: "ka",  notes: "" },
    { en: "he / she", cl: "ua", notes: "3rd person singular." },
    { en: "I / me", cl: "owa", notes: "1st person singular." },
    { en: "lay down", cl: "kwo", notes: "Verb." },
    { en: "night",  cl: "a",   notes: "" },
    { en: "no / not / negative", cl: "noa", notes: "Negation marker." },
    { en: "pillow", cl: "teq", notes: "Pronounced 'tek'." },
    { en: "question marker", cl: "uta", notes: "Sentence-final question particle." },
    { en: "sleep",  cl: "nna", notes: "Verb." },
    { en: "they / you all", cl: "ena", notes: "Plural 3rd person / 'you all'." },
    { en: "tired",  cl: "jna", notes: "" },
    { en: "today",  cl: "ani", notes: "" },
    { en: "wake up", cl: "ba", notes: "Verb." },
    { en: "we",     cl: "vja", notes: "1st person plural." },
    { en: "wish",   cl: "lno", notes: "Verb." },
    { en: "you",    cl: "ma",  notes: "2nd person singular." }
  ];

  const q = document.getElementById("q");
  const mode = document.getElementById("mode");
  const clearBtn = document.getElementById("clear");
  const rowsEl = document.getElementById("rows");
  const countEl = document.getElementById("count");
  const showingEl = document.getElementById("showing");

  const esc = (s) => (s ?? "").toString()
    .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
    .replaceAll('"',"&quot;").replaceAll("'","&#039;");

  const norm = (s) => (s ?? "").toString().trim().toLowerCase();

  const sorted = [...LEXICON].sort((a,b) => a.en.localeCompare(b.en, "en", { sensitivity:"base" }));
  countEl.textContent = String(sorted.length);

  function match(entry, query, m){
    if (!query) return true;
    const EN = norm(entry.en), CL = norm(entry.cl), NO = norm(entry.notes);
    if (m === "en") return EN.includes(query);
    if (m === "cl") return CL.includes(query);
    if (m === "notes") return NO.includes(query);
    return EN.includes(query) || CL.includes(query) || NO.includes(query);
  }

  function render(list){
    showingEl.textContent = String(list.length);
    if (!list.length){
      rowsEl.innerHTML = `<tr><td colspan="3" class="muted">No matches.</td></tr>`;
      return;
    }

    rowsEl.innerHTML = list.map(e => `
      <tr>
        <td data-label="English"><span class="mono">${esc(e.en)}</span></td>
        <td data-label="Conlang"><span class="mono"><strong>${esc(e.cl)}</strong></span></td>
        <td data-label="Notes" class="muted">${esc(e.notes || "")}</td>
      </tr>
    `).join("");
  }

  function update(){
    const query = norm(q.value);
    const m = mode.value;
    render(sorted.filter(e => match(e, query, m)));
  }

  q.addEventListener("input", update);
  mode.addEventListener("change", update);
  clearBtn.addEventListener("click", () => {
    q.value = "";
    mode.value = "both";
    update();
    q.focus();
  });

  render(sorted);
</script>
</body>
</html>
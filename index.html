<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fliplish Translator</title>

  <style>
    :root {
      --bg: #d8cbb8;
      --panel: rgba(255,255,255,0.78);
      --border: rgba(17, 24, 39, 0.18);
      --text: #111827;
    }

    * { box-sizing: border-box; }
    html, body { overflow-x: hidden; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, sans-serif;
      margin: 24px;
      line-height: 1.35;
      background: var(--bg);
      color: var(--text);
    }

    .container {
      max-width: 820px;
      margin: 0 auto;
      width: 100%;
    }

    textarea {
      width: 100%;
      min-height: 140px;
      padding: 12px;
      font-size: 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      outline: none;
    }

    .row {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
      align-items: center;
    }

    button, select, input[type="checkbox"] {
      font-size: 15px;
    }

    button, select {
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.65);
      cursor: pointer;
    }

    label.chk {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.45);
      user-select: none;
    }

    .hint { opacity: 0.75; font-size: 13px; margin-top: 8px; }
  </style>
</head>

<body>
<div class="container">
  <h1>Fliplish Translator</h1>

  <textarea id="input" placeholder="Type English (or coded text) here..."></textarea>

  <div class="row">
    <button id="encode">Encode →</button>
    <button id="decode">← Decode</button>
    <button id="clear">Clear</button>

    <label>
      Suffix mode:
      <select id="suffixMode">
        <option value="single" selected>Single</option>
        <option value="aeo">AEO Rotate</option>
        <option value="random">Random</option>
      </select>
    </label>

    <label>
      Suffix:
      <select id="suffix"></select>
    </label>

    <label>
      Move letters:
      <select id="moveN">
        <option value="1" selected>1</option>
        <option value="2">2</option>
      </select>
    </label>

    <label>
      Preserve capitalization:
      <select id="caps">
        <option value="yes">Yes</option>
        <option value="no" selected>No</option>
      </select>
    </label>

    <label class="chk" title="Recommended: Decode auto-detects per word (works even if sender used different settings)">
      <input id="smartDecode" type="checkbox" checked />
      Smart Decode
    </label>
  </div>

  <textarea id="output" readonly></textarea>

  <div class="hint">
    How Fliplish works: Each word is encoded by moving the first one or two letters to the end of the word and then adding a suffix.
    To decode, the suffix is removed and those letters are moved back to the front, restoring the original word.
    Punctuation, spacing, and contractions (like I’m or don’t) are preserved so the text stays readable.
  </div>
</div>

<script>
/** ====== Suffixes ====== **/
const LETTERS = "abcdefghijklmnopqrstuvwxyz".split("");
const EXTRA_SUFFIXES = ["sh", "ch", "th"]; // shown first
const ALL_SUFFIXES = [...EXTRA_SUFFIXES, ...LETTERS];

/** ====== Elements ====== **/
const inputEl = document.getElementById("input");
const outputEl = document.getElementById("output");
const suffixEl = document.getElementById("suffix");
const suffixModeEl = document.getElementById("suffixMode");
const moveNEl = document.getElementById("moveN");
const capsEl = document.getElementById("caps");
const smartDecodeEl = document.getElementById("smartDecode");

/** ====== Init suffix dropdown (SH/CH/TH then A-Z) ====== **/
(function initSuffix() {
  suffixEl.innerHTML = "";
  for (const s of ALL_SUFFIXES) {
    const o = document.createElement("option");
    o.value = s;
    o.textContent = s.toUpperCase();
    if (s === "a") o.selected = true;
    suffixEl.appendChild(o);
  }
})();

/** Disable manual suffix picker in AEO/Random mode */
function syncSuffixUI() {
  const mode = suffixModeEl.value;
  const disabled = (mode === "aeo" || mode === "random");
  suffixEl.disabled = disabled;
  suffixEl.style.opacity = disabled ? "0.55" : "1";
}
suffixModeEl.addEventListener("change", syncSuffixUI);
syncSuffixUI();

/** ====== Tokenizer ======
  Keeps words together and preserves punctuation.
  Also keeps apostrophes inside words (I'm, don't) as part of the token.
**/
function tokenize(text) {
  return text.match(/[A-Za-z]+(?:['’][A-Za-z]+)*|[^A-Za-z]+/g) || [];
}

function detectCapsStyle(word) {
  if (word === word.toUpperCase()) return "upper";
  if (word[0] === word[0].toUpperCase() && word.slice(1) === word.slice(1).toLowerCase()) return "title";
  return "lower";
}

/** ====== Apostrophe-safe helpers ======
  We do the letter-moving on letters only, then re-insert apostrophes
  at their original indices so contractions stay like I'm (not 'im).
**/
function splitApostrophes(word) {
  const letters = [];
  const apos = [];
  [...word].forEach((c, i) => {
    if (c === "'" || c === "’") apos.push({ i, c });
    else letters.push(c);
  });
  return { letters: letters.join(""), apos };
}

function restoreApostrophes(word, apos) {
  const arr = [...word];
  apos.forEach(({ i, c }) => {
    const idx = Math.max(0, Math.min(i, arr.length));
    arr.splice(idx, 0, c);
  });
  return arr.join("");
}

/** ====== Core encode/decode ====== **/
function encodeWord(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();
  const { letters, apos } = splitApostrophes(lower);
  if (!letters) return word;

  const n = Math.min(moveN, letters.length);
  let codedLetters = letters.slice(n) + letters.slice(0, n) + suffix;
  let coded = restoreApostrophes(codedLetters, apos);

  if (!preserveCaps) return coded;
  if (style === "upper") return coded.toUpperCase();
  if (style === "title") return coded[0].toUpperCase() + coded.slice(1);
  return coded;
}

function decodeWord(word, suffix, preserveCaps, moveN) {
  const style = preserveCaps ? detectCapsStyle(word) : "lower";
  const lower = word.toLowerCase();
  if (!lower.endsWith(suffix)) return word;

  const core = lower.slice(0, -suffix.length);
  const { letters, apos } = splitApostrophes(core);
  if (!letters) return word;

  const n = Math.min(moveN, letters.length);
  let plainLetters = letters.slice(-n) + letters.slice(0, -n);
  let plain = restoreApostrophes(plainLetters, apos);

  if (!preserveCaps) return plain;
  if (style === "upper") return plain.toUpperCase();
  if (style === "title") return plain[0].toUpperCase() + plain.slice(1);
  return plain;
}

/** ====== Suffix selection ====== **/
function randomSuffix() {
  return ALL_SUFFIXES[Math.floor(Math.random() * ALL_SUFFIXES.length)];
}

function getSuffixForWord(i) {
  const mode = suffixModeEl.value;
  if (mode === "aeo") return ["a","e","o"][i % 3];
  if (mode === "random") return randomSuffix();
  return suffixEl.value; // single
}

/** Pull suffix from a token (supports 2-letter suffixes SH/CH/TH) */
function suffixFromToken(tok) {
  const low = tok.toLowerCase();
  // prefer longest match first
  for (const s of EXTRA_SUFFIXES) {
    if (low.endsWith(s)) return s;
  }
  // fallback 1-letter
  const last = low[low.length - 1] || "";
  return /[a-z]/.test(last) ? last : null;
}

/** ====== Smart Decode ======
  Try moveN=1 and moveN=2 (using the suffix found on the word)
  and pick the result that "looks most like a real word".
**/
const COMMON = new Set([
  "the","a","an","and","or","but","is","are","was","were","be","been","being",
  "i","you","he","she","it","we","they","me","him","her","us","them",
  "my","your","his","hers","our","their",
  "to","of","in","on","at","for","from","with","as","by",
  "this","that","these","those","not","no","yes",
  "table","carpet","front","house","road","store","tomorrow","today","now","then",
  "test","program"  // ✅ added for your exact test case
]);

const COMMON_TRI = ["the","and","pro","con","int","for","tha","thi","wit","you","not","are","was"];

function scorePlainWord(w) {
  const low = w.toLowerCase();
  const lettersOnly = low.replace(/[^a-z]/g, "");
  if (lettersOnly.length === 0) return -999;

  let score = 0;

  // Big reward for being a common word
  if (COMMON.has(lettersOnly)) score += 8;

  // Vowels help a lot (pronounceable-ish)
  const vowels = (lettersOnly.match(/[aeiouy]/g) || []).length;
  score += vowels * 2;

  // Penalize nasty clusters
  if (/[^aeiouy]{5,}/.test(lettersOnly)) score -= 7;     // 5 consonants in a row
  if (/[jqxz]{2,}/.test(lettersOnly)) score -= 6;        // rare-letter spam
  if (/(.)\1\1/.test(lettersOnly)) score -= 3;           // triple same letter

  // Light reward for common endings
  if (/(ing|ed|ly|tion|s)$/.test(lettersOnly)) score += 2;

  // Apostrophe sanity (should not lead)
  if (low.includes("'") || low.includes("’")) {
    if (/^['’]/.test(low)) score -= 10; // bad: starts with apostrophe
    if (/[a-z]['’][a-z]/.test(low)) score += 2; // normal contraction pattern
  }

  return score;
}

/** ✅ REPLACED smartDecodeToken with improved tie-break logic */
function smartDecodeToken(tok, preserveCaps) {
  const sfx = suffixFromToken(tok);
  if (!sfx) return tok;

  const cand1 = decodeWord(tok, sfx, preserveCaps, 1);
  const cand2 = decodeWord(tok, sfx, preserveCaps, 2);

  const sc1 = scorePlainWord(cand1);
  const sc2 = scorePlainWord(cand2);

  // Clear winner
  if (sc2 > sc1 + 1) return cand2;
  if (sc1 > sc2 + 1) return cand1;

  // If close/tied, prefer the one that matches common words/trigrams
  const a = cand1.toLowerCase().replace(/[^a-z'’]/g, "");
  const b = cand2.toLowerCase().replace(/[^a-z'’]/g, "");

  const aClean = a.replace(/['’]/g, "");
  const bClean = b.replace(/['’]/g, "");

  if (COMMON.has(bClean) && !COMMON.has(aClean)) return cand2;
  if (COMMON.has(aClean) && !COMMON.has(bClean)) return cand1;

  const a3 = aClean.slice(0,3);
  const b3 = bClean.slice(0,3);
  if (COMMON_TRI.includes(b3) && !COMMON_TRI.includes(a3)) return cand2;
  if (COMMON_TRI.includes(a3) && !COMMON_TRI.includes(b3)) return cand1;

  // Final tie-breaker: default to move=2 (fixes estt/rogramp style fails)
  return cand2;
}

/** ====== Transform ====== **/
function transform(text, mode) {
  const preserveCaps = capsEl.value === "yes";
  let wordIndex = 0;

  return tokenize(text).map(tok => {
    if (/^[A-Za-z]/.test(tok)) {
      if (mode === "encode") {
        const moveN = +moveNEl.value;
        const suffix = getSuffixForWord(wordIndex);
        wordIndex++;
        return encodeWord(tok, suffix, preserveCaps, moveN);
      } else {
        // DECODE
        const useSmart = !!smartDecodeEl?.checked;

        if (useSmart) {
          wordIndex++;
          return smartDecodeToken(tok, preserveCaps);
        }

        const moveN = +moveNEl.value;
        const suffix = suffixFromToken(tok) || getSuffixForWord(wordIndex);
        wordIndex++;
        return decodeWord(tok, suffix, preserveCaps, moveN);
      }
    }
    return tok;
  }).join("");
}

/** ====== Buttons ====== **/
document.getElementById("encode").onclick = () =>
  outputEl.value = transform(inputEl.value, "encode");

document.getElementById("decode").onclick = () =>
  outputEl.value = transform(inputEl.value, "decode");

document.getElementById("clear").onclick = () => {
  inputEl.value = "";
  outputEl.value = "";
  inputEl.focus();
};
</script>
</body>
</html>